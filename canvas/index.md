## 画布宽高和样式宽高

画布宽高指的是在canvas标签上设置宽高

```html
<canvas width="512" height="512"></canvas>
```

样式宽高指的是使用css设置的宽高

```css
canvas {
  width: 256px;
  height: 256px;
}
```

画布宽高决定了canvas的坐标系，而样式宽高决定了canvas显示的大小。

坐标系和显示大小分离是十分明智的选择，可以适应各种不同大小的设置（比如我们要设置一个元素的canvas中居中就之和canvas的坐标系有关）不用开发人员针对不用的大小做不同的操作，减少开发人员的心智负担。

## 坐标系

左上角为坐标原点，X轴水平向右，Y轴垂直向下。

## 绘图

### 1、获取canvas上下文
```js
// 1. 获取canvas元素
const canvas = document.querySelector('canvas')

// 2. 获取上下文
const context = canvas.getContext('2d')
```

### 2、绘制图形

我们拿到的 context 对象上会有许多 API，它们大体上可以分为两类：**一类是设置状态的 API，可以设置或改变当前的绘图状态，比如，改变要绘制图形的颜色、线宽、坐标变换等等；另一类是绘制指令 API，用来绘制不同形状的几何图形。**

1. 获取 Canvas 对象
2. 通过 getContext(‘2d’) 得到 2D 上下文
3. 设置绘图状态，比如填充颜色 fillStyle，平移变换 translate 等等
4. 调用 beginPath 指令开始绘制图形
5. 调用绘图指令，比如 rect，表示绘制矩形
6. 调用 fill 指令，将绘制内容真正输出到画布上

## 画布状态

画布的初始状态为 S，画布可以进行一些平移操作，这样画布状态就到了一个新的状态 S1，我们在新的状态 S1 上绘制图形 rect，然后将画布恢复为 S 状态，在 S1 绘制的图形也不会受到影响。

所以**canvas绘制的图形是根据当前上下文的状态决定的，并且已经绘制好的图形在上下文状态发生变化是不会受到影响。**

对于状态的来回切换可以采用方向的操作，比如
```js
// 平移
context.translate(x, y)

// ... 执行绘制

// 恢复
context.translate(-x, -y)
```

也可以采用canvas的提供的API来进行操作

```js
// 暂存状态
context.save()

// 平移
context.translate(x, y)

// ... 执行绘制

// 恢复状态
context.restore()
```

Canvas 是一个非常简单易用的图形系统。结合刚才的例子你也能感受到，Canvas 通过一组简单的绘图指令，就能够方便快捷地绘制出各种复杂的几何图形。

另外，Canvas 渲染起来相当高效。即使是绘制大量轮廓非常复杂的几何图形，Canvas 也只需要调用一组简单的绘图指令就能高性能地完成渲染。这个呀，其实和**Canvas更偏向于渲染层，能够提供底层的图形渲染 API**有关。那在实际实现可视化业务的时候，Canvas 出色的渲染能力正是它的优势所在。

不过 Canvas 也有缺点，因为 Canvas 在 HTML 层面上是一个独立的画布元素，所以所有的绘制内容都是在内部通过绘图指令来完成的，绘制出的图形对于浏览器来说，只是 Canvas 中的一个个像素点，我们很难直接抽取其中的图形对象进行操作。

比如说，在 HTML 或 SVG 中绘制一系列图形的时候，我们可以一一获取这些图形的元素对象，然后给它们绑定用户事件。但同样的操作在 Canvas 中没有可以实现的简单方法（但是我们仍然可以和 Canvas 图形交互，在后续课程中我们会有专门讨论）。下一节课中，我们会详细讲解 SVG 图形系统，到时你就会更加明白它们的差异具体是什么了。
